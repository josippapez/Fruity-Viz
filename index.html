<!DOCTYPE html>
<head>
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
    integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay"
    crossorigin="anonymous"
  />
  <link rel="stylesheet" type="text/css" href="./css/style.css" />
  <link rel="stylesheet" type="text/css" href="./css/checkbox.css" />
  <link rel="stylesheet" type="text/css" href="./css/fonts/fonts.css" />
  <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  <script src="./scripts/libs/divgrid.js"></script>
  <script src="./scripts/libs/d3.parcoords.js"></script>
</head>

<body>
  <div class="graphs">
    <nav class="nav-icons">
      <a href="index.html" class="menu-dark">
        <span>Line graph</span>
        <i class="fab fa-think-peaks"></i>
      </a>
      <a href="radar.html" class="menu-orange">
        <span>Radar Chart</span>
        <i class="fas fa-crosshairs"></i>
      </a>
    </nav>
    <hr />
    <div id="grid"></div>
    <div id="parallelCoords" class="parcoords"></div>
  </div>
</body>

<script>
  var itemsToDisplay = [];

  function getRandomColor() {
    var letters = "0123456789ABCDEF";
    var color = "#";
    for (var i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }

  var color = function (d) {
    return getRandomColor();
  };

  var grid = d3.divgrid();

  var margin = { top: 30, right: 10, bottom: 10, left: 10 },
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

  var x = d3.scale.ordinal().rangePoints([0, width], 1),
    y = {},
    dragging = {};

  var line = d3.svg.line(),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground;

  var svg = d3
    .select("#parallelCoords")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  d3.csv("./data/fruits.csv", function (error, fruit) {
    // Extract the list of dimensions and create a scale for each.
    x.domain(
      (dimensions = d3.keys(fruit[0]).filter(function (d) {
        return (
          d != "name" &&
          (y[d] = d3.scale
            .linear()
            .domain(
              d3.extent(fruit, function (p) {
                return +p[d];
              })
            )
            .range([height, 0]))
        );
      }))
    );

    d3.select("#grid").datum(fruit).call(grid);

    // Add grey background lines for context.
    background = svg
      .append("g")
      .attr("class", "background")
      .selectAll("path")
      .data(fruit)
      .enter()
      .append("path")
      .attr("d", path);

    // Add blue foreground lines for focus.
    foreground = svg
      .append("g")
      .attr("class", "foreground")
      .selectAll("path")
      .data(fruit)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("id", (d) => d.name);

    d3.select("#grid")
      .datum(fruit)
      .call(grid)
      .selectAll(".row")
      .on({
        mouseover: function (d) {
          document.getElementById(d.name).style = "stroke-width: 5px";
        },
      })
      .on({
        mouseout: function (d) {
          document.getElementById(d.name).style = "stroke-width: 1px";
        },
      });
    // Add a group element for each dimension.

    var g = svg
      .selectAll(".dimension")
      .data(dimensions)
      .enter()
      .append("g")
      .attr("class", "dimension")
      .attr("transform", function (d) {
        return "translate(" + x(d) + ")";
      })
      .call(
        d3.behavior
          .drag()
          .origin(function (d) {
            return { x: x(d) };
          })
          .on("dragstart", function (d) {
            dragging[d] = x(d);
            background.attr("visibility", "hidden");
          })
          .on("drag", function (d) {
            dragging[d] = Math.min(width, Math.max(0, d3.event.x));
            foreground.attr("d", path);
            dimensions.sort(function (a, b) {
              return position(a) - position(b);
            });
            x.domain(dimensions);
            g.attr("transform", function (d) {
              return "translate(" + position(d) + ")";
            });
          })
          .on("dragend", function (d) {
            delete dragging[d];
            transition(d3.select(this)).attr(
              "transform",
              "translate(" + x(d) + ")"
            );
            transition(foreground).attr("d", path);
            background
              .attr("d", path)
              .transition()
              .delay(500)
              .duration(0)
              .attr("visibility", null);
          })
      );

    // Add an axis and title.
    g.append("g")
      .attr("class", "axis")
      .each(function (d) {
        d3.select(this).call(axis.scale(y[d]));
      })
      .append("text")
      .style("text-anchor", "middle")
      .attr("y", -9)
      .text(function (d) {
        return d;
      });

    // Add and store a brush for each axis.
    g.append("g")
      .attr("class", "brush")
      .each(function (d) {
        d3.select(this).call(
          (y[d].brush = d3.svg
            .brush()
            .y(y[d])
            .on("brushstart", brushstart)
            .on("brush", () => brush(fruit)))
        );
      })
      .selectAll("rect")
      .attr("x", -8)
      .attr("width", 16);
  });

  function drawGrid(data) {
    // Odabir div-a u kojem će se crtati tablica, te podaci koji će se nalaziti u tablici
    // U slučaju da postoji neki tekst, u tablici će se nalaziti svi Pokemoni čije ime
    // sadržava tekst u polju za pretragu. Ako tekst ne postoji, u tablici će se nalaziti
    // prvih 20 podataka koji odgovaraju kriterijima.
    // Svakom retku dodaje se mouseover listener koji će označiti taj podatak na grafu i pretvoriti
    // izgled miša, mouseout listener koji će ukloniti efekt označavanja, te click listener
    // koji će navigirati do druge vizualizacije zajedno s id-jem Pokemona kao query string

    // IZVORI:
    // https://gist.github.com/syntagmatic/3687826
    // http://bl.ocks.org/eesur/1a2514440351ec22f176
    d3.select("#grid")
      .datum(
        data.filter(
          (d) =>
            document.getElementById(`active-highlighted-item${d.name}`) &&
            !document.getElementById(`active-highlighted-item${d.name}`).style
              .display &&
            d
        )
      )
      .call(grid)
      .selectAll(".row")
      .on({
        mouseover: function (d) {
          document.getElementById(`active-highlighted-item${d.name}`).style =
            "stroke-width: 5px";
        },
      })
      .on({
        mouseout: function (d) {
          document.getElementById(`active-highlighted-item${d.name}`).style =
            "stroke-width: 1px";
        },
      });
  }

  function position(d) {
    var v = dragging[d];
    return v == null ? x(d) : v;
  }

  function transition(g) {
    return g.transition().duration(500);
  }

  // Returns the path for a given data point.
  function path(d) {
    return line(
      dimensions.map(function (p) {
        return [position(p), y[p](d[p])];
      })
    );
  }

  function brushstart() {
    d3.event.sourceEvent.stopPropagation();
  }

  // Handles a brush event, toggling the display of foreground lines.
  function brush(fruit) {
    var actives = dimensions.filter(function (p) {
        return !y[p].brush.empty();
      }),
      extents = actives.map(function (p) {
        return y[p].brush.extent();
      });
    foreground
      .style("display", function (d) {
        return actives.every(function (p, i) {
          if (extents[i][0] <= d[p] && d[p] <= extents[i][1]) {
            return true;
          }
        })
          ? null
          : "none";
      })
      .attr("id", (d) => `active-highlighted-item${d.name}`);
    drawGrid(fruit);
  }
</script>
